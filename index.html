<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spotify Card Prototype</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 24px; background: #0b0b0d; color: #fff; }
    .wrap { display: grid; grid-template-columns: 1fr 420px; gap: 18px; align-items: start; max-width: 1200px; margin: 0 auto; }
    .panel { background: #141418; border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 16px; }
    input { width: 100%; padding: 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.12); background: #0f0f13; color: #fff; }
    button { padding: 10px 12px; border-radius: 10px; border: 0; background: #27e5a5; color: #04110b; font-weight: 650; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    label { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
    .muted { color: rgba(255,255,255,.62); font-size: 13px; line-height: 1.4; }
    canvas { width: 100%; height: auto; border-radius: 16px; background: #111; border: 1px solid rgba(255,255,255,.08); }
    .row { display:flex; gap:10px; margin-top: 10px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <h2 style="margin:0 0 10px;">Preview</h2>
      <canvas id="card" width="1080" height="1920"></canvas>
      <div class="row">
        <button id="downloadBtn" onclick="downloadPng()" disabled>Download PNG (1080×1920)</button>
        <button onclick="render()">Refresh</button>
      </div>
      <p class="muted" id="status" style="margin-top:10px;"></p>
    </div>

    <div class="panel">
      <h2 style="margin:0 0 10px;">Input</h2>
      <input id="url" placeholder="Paste Spotify track link…" />
      <div class="row">
        <button id="loadBtn" onclick="loadTrack()">Load</button>
      </div>

      <h3 style="margin:18px 0 6px;">Options</h3>
      <label><input type="checkbox" id="optCover" checked onchange="render()">Album cover</label>
      <label><input type="checkbox" id="optTitle" checked onchange="render()">Song title</label>
      <label><input type="checkbox" id="optArtist" checked onchange="render()">Artist name (fallback if missing)</label>
      <label><input type="checkbox" id="optYear" onchange="render()">Year (not available in oEmbed MVP)</label>

      <h3 style="margin:18px 0 6px;">Debug</h3>
      <pre id="debug" class="muted" style="white-space: pre-wrap; margin:0;"></pre>

      <p class="muted" style="margin-top:12px;">
        Note: oEmbed may not include artist/year for some tracks. We’ll add a “year + album name” data source later.
      </p>
    </div>
  </div>

  <script>
    const state = {
      canonicalUrl: "",
      title: "",
      artist: "",
      year: "",
      coverUrl: "",
      palette: ["#1a1a1a", "#2a2a2a", "#111"]
    };

    async function loadTrack() {
      setStatus("Resolving URL…");
      const url = document.getElementById("url").value.trim();
      if (!url) return setStatus("Please paste a Spotify link.");

      // 1) resolve
      const r1 = await fetch(`/api/resolve?url=${encodeURIComponent(url)}`);
      const j1 = await r1.json();
      if (!r1.ok) {
        document.getElementById("debug").textContent = JSON.stringify(j1, null, 2);
        return setStatus("Resolve failed. See debug.");
      }

      state.canonicalUrl = j1.canonicalUrl || url;

      // 2) oembed
      setStatus("Fetching oEmbed…");
      const r2 = await fetch(`/api/oembed?url=${encodeURIComponent(state.canonicalUrl)}`);
      const j2 = await r2.json();
      document.getElementById("debug").textContent = JSON.stringify({ resolve: j1, oembed: j2 }, null, 2);

      if (!r2.ok) return setStatus("oEmbed failed. See debug.");

      state.title = j2.title || "";
      state.artist = j2.author_name || ""; // may be missing
      state.coverUrl = j2.thumbnail_url || "";
      state.year = ""; // oEmbed MVP no year

      // palette from cover
      if (state.coverUrl) {
        setStatus("Loading cover & extracting colors…");
        try {
          state.palette = await extractPalette(state.coverUrl);
        } catch (e) {
          // fallback
        }
      }

      document.getElementById("downloadBtn").disabled = false;
      setStatus("Loaded. Rendering…");
      render();
      setStatus("Ready.");
    }

    function setStatus(s) { document.getElementById("status").textContent = s; }

    async function render() {
      const canvas = document.getElementById("card");
      const ctx = canvas.getContext("2d");
      const W = canvas.width, H = canvas.height;

      const showCover = document.getElementById("optCover").checked;
      const showTitle = document.getElementById("optTitle").checked;
      const showArtist = document.getElementById("optArtist").checked;
      const showYear = document.getElementById("optYear").checked;

      // background gradient from palette
      const [c1, c2, c3] = state.palette;
      const g = ctx.createLinearGradient(0, 0, W, H);
      g.addColorStop(0, c1);
      g.addColorStop(0.55, c2);
      g.addColorStop(1, c3);
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // subtle texture (noise)
      drawNoise(ctx, W, H, 0.06);

      // layout
      const pad = 96;
      const coverSize = 820;
      const coverX = (W - coverSize) / 2;
      const coverY = 190;

      // cover
      if (showCover && state.coverUrl) {
        const img = await loadImage(state.coverUrl);
        roundRectImage(ctx, img, coverX, coverY, coverSize, coverSize, 36);
        // slight shadow under cover
        ctx.save();
        ctx.globalAlpha = 0.16;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        roundedRectPath(ctx, coverX, coverY + coverSize + 28, coverSize, 18, 9);
        ctx.fill();
        ctx.restore();
      }

      // text block
      const textY = coverY + coverSize + 120;

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.textAlign = "left";

      let y = textY;

      if (showTitle) {
        ctx.font = "800 86px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        const title = state.title || "—";
        y = drawWrappedText(ctx, title, pad, y, W - pad*2, 92, 2);
        y += 18;
      }

      const artistLine = state.artist || "Unknown artist";
      if (showArtist) {
        ctx.font = "600 52px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,.78)";
        y = drawWrappedText(ctx, artistLine, pad, y, W - pad*2, 62, 2);
        y += 12;
      }

      if (showYear) {
        ctx.font = "600 44px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,.62)";
        ctx.fillText(state.year || "—", pad, y);
      }

      // tiny footer
      ctx.fillStyle = "rgba(255,255,255,.40)";
      ctx.font = "500 30px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText("Generated via Spotify oEmbed", pad, H - 78);
    }

    function downloadPng() {
      const canvas = document.getElementById("card");
      const a = document.createElement("a");
      a.download = "spotify-card.png";
      a.href = canvas.toDataURL("image/png");
      a.click();
    }

    // ---------- helpers ----------
    function drawNoise(ctx, W, H, alpha) {
      const imgData = ctx.getImageData(0, 0, W, H);
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const n = (Math.random() - 0.5) * 24;
        d[i] += n; d[i+1] += n; d[i+2] += n;
      }
      ctx.putImageData(imgData, 0, 0);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }

    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    async function extractPalette(coverUrl) {
      const img = await loadImage(coverUrl);
      const c = document.createElement("canvas");
      const s = 80;
      c.width = s; c.height = s;
      const x = c.getContext("2d");
      x.drawImage(img, 0, 0, s, s);
      const data = x.getImageData(0, 0, s, s).data;

      // simple quantize-ish: sample pixels, bucket by rough RGB
      const buckets = new Map();
      for (let i = 0; i < data.length; i += 16) {
        const r = data[i], g = data[i+1], b = data[i+2];
        const key = `${Math.round(r/24)},${Math.round(g/24)},${Math.round(b/24)}`;
        buckets.set(key, (buckets.get(key) || 0) + 1);
      }

      const top = [...buckets.entries()].sort((a,b)=>b[1]-a[1]).slice(0,6).map(([k])=>{
        const [rr,gg,bb] = k.split(",").map(v=>parseInt(v,10)*24);
        return rgbToHex(clamp(rr), clamp(gg), clamp(bb));
      });

      // pick 3 distinct-ish colors
      const pick = [];
      for (const col of top) {
        if (pick.length === 0) pick.push(col);
        else if (pick.length === 1 && distanceHex(col, pick[0]) > 60) pick.push(col);
        else if (pick.length === 2 && distanceHex(col, pick[0]) > 60 && distanceHex(col, pick[1]) > 60) { pick.push(col); break; }
      }
      while (pick.length < 3) pick.push(["#1a1a1a","#2a2a2a","#111"][pick.length]);
      return pick;
    }

    function clamp(v){ return Math.max(0, Math.min(255, v)); }
    function rgbToHex(r,g,b){
      return "#" + [r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("");
    }
    function hexToRgb(h){
      const m = h.replace("#","").match(/.{2}/g).map(x=>parseInt(x,16));
      return {r:m[0], g:m[1], b:m[2]};
    }
    function distanceHex(a,b){
      const A = hexToRgb(a), B = hexToRgb(b);
      return Math.sqrt((A.r-B.r)**2 + (A.g-B.g)**2 + (A.b-B.b)**2);
    }

    function roundedRectPath(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function roundRectImage(ctx, img, x, y, w, h, r) {
      ctx.save();
      roundedRectPath(ctx, x, y, w, h, r);
      ctx.clip();
      ctx.drawImage(img, x, y, w, h);
      ctx.restore();
    }

    function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight, maxLines) {
      const words = String(text).split(/\s+/);
      let line = "";
      let lines = 0;
      for (let i=0; i<words.length; i++) {
        const test = line ? line + " " + words[i] : words[i];
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          ctx.fillText(line, x, y);
          y += lineHeight;
          lines++;
          line = words[i];
          if (lines >= maxLines-1) break;
        }
      }
      // last line
      if (lines < maxLines) {
        const remaining = line || "";
        // ellipsis if too long
        let out = remaining;
        while (ctx.measureText(out).width > maxWidth && out.length > 1) out = out.slice(0, -1);
        if (out !== remaining) out = out.slice(0, Math.max(0,out.length-1)) + "…";
        ctx.fillText(out, x, y);
        y += lineHeight;
      }
      return y;
    }

    // Initial render placeholder
    render();
  </script>
</body>
</html>
