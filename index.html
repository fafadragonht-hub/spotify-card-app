<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spotify Card (Banner POC)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0; padding: 24px;
      background: #0b0b0d; color: #fff;
    }
    .wrap {
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 18px;
      align-items: start;
      max-width: 1200px;
      margin: 0 auto;
    }
    .panel {
      background: #141418;
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 16px;
    }
    input[type="text"], input[type="url"] {
      width: 100%;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: #0f0f13;
      color: #fff;
      box-sizing: border-box;
    }
    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 0;
      background: #27e5a5;
      color: #04110b;
      font-weight: 650;
      cursor: pointer;
    }
    button:disabled { opacity: .5; cursor: not-allowed; }
    label { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
    .muted { color: rgba(255,255,255,.62); font-size: 13px; line-height: 1.4; }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 12px;
      background: #0b0b0d;
      border: 1px solid rgba(255,255,255,.08);
    }
    .row { display:flex; gap:10px; margin-top: 10px; flex-wrap: wrap; }
    h2, h3 { margin: 0 0 10px; }
    .fieldLabel { display:block; margin: 10px 0 6px; font-size: 13px; color: rgba(255,255,255,.72); }
    pre {
      white-space: pre-wrap;
      margin: 0;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.06);
      padding: 12px;
      border-radius: 10px;
      overflow: auto;
      max-height: 260px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <h2>Preview (638×300)</h2>
      <canvas id="card" width="638" height="300"></canvas>
      <div class="row">
        <button id="downloadBtn" onclick="downloadPng()" disabled>Download PNG (638×300)</button>
        <button onclick="render()">Refresh</button>
      </div>
      <p class="muted" id="status" style="margin-top:10px;"></p>
    </div>

    <div class="panel">
      <h2>Input</h2>
      <input id="url" type="url" placeholder="Paste Spotify track link…" />
      <div class="row">
        <button id="loadBtn" onclick="loadTrack()">Load</button>
      </div>

      <h3 style="margin:18px 0 6px;">Options</h3>
      <label><input type="checkbox" id="optCover" checked onchange="render()">Album cover</label>
      <label><input type="checkbox" id="optTitle" checked onchange="render()">Song title</label>
      <label><input type="checkbox" id="optArtist" checked onchange="render()">Artist name</label>
      <label><input type="checkbox" id="optYear" checked onchange="render()">Year (manual)</label>

      <h3 style="margin:18px 0 6px;">Manual fields</h3>
      <span class="fieldLabel">Artist (override)</span>
      <input id="artistManual" type="text" placeholder="Type artist name…" oninput="render()" />
      <span class="fieldLabel">Year (override)</span>
      <input id="yearManual" type="text" placeholder="e.g. 2021" inputmode="numeric" oninput="render()" />

      <h3 style="margin:18px 0 6px;">Debug</h3>
      <pre id="debug" class="muted"></pre>

      <p class="muted" style="margin-top:12px;">Uses Spotify oEmbed for title + cover. Artist/year are manual overrides.</p>
    </div>
  </div>

  <script>
    const state = {
      canonicalUrl: "",
      title: "",
      artist: "",
      year: "",
      coverUrl: ""
    };

    function setStatus(s) { document.getElementById("status").textContent = s; }
    function setDebug(obj) { document.getElementById("debug").textContent = JSON.stringify(obj, null, 2); }

    // Try /api/* first; fallback to /.netlify/functions/*
    async function fetchJsonSmart(name, params) {
      const qs = new URLSearchParams(params).toString();
      const urls = [
        `/api/${name}?${qs}`,
        `/.netlify/functions/${name}?${qs}`
      ];
      let lastErr = null;
      for (const u of urls) {
        try {
          const r = await fetch(u);
          const text = await r.text();
          let j = null;
          try { j = JSON.parse(text); } catch { j = { raw: text }; }
          if (!r.ok) throw new Error(`${u} -> ${r.status} ${text}`);
          return { ok: true, url: u, data: j };
        } catch (e) {
          lastErr = e;
        }
      }
      return { ok: false, error: String(lastErr || "Unknown error") };
    }

    async function loadTrack() {
      const url = document.getElementById("url").value.trim();
      if (!url) { setStatus("Please paste a Spotify link."); return; }

      document.getElementById("downloadBtn").disabled = true;
      setStatus("Resolving URL…");

      const res1 = await fetchJsonSmart("resolve", { url });
      if (!res1.ok) {
        setDebug({ error: "resolve failed", detail: res1.error });
        setStatus("Resolve failed. See Debug.");
        return;
      }

      state.canonicalUrl = res1.data.canonicalUrl || url;

      setStatus("Fetching oEmbed…");
      const res2 = await fetchJsonSmart("oembed", { url: state.canonicalUrl });
      if (!res2.ok) {
        setDebug({ resolve: res1.data, error: "oembed failed", detail: res2.error });
        setStatus("oEmbed failed. See Debug.");
        return;
      }

      const o = res2.data;
      state.title = o.title || "";
      state.coverUrl = o.thumbnail_url || "";

      // Manual overrides (always win if provided)
      const manualArtist = document.getElementById("artistManual").value.trim();
      const manualYear = document.getElementById("yearManual").value.trim();
      state.artist = manualArtist || (o.author_name || "");
      state.year = manualYear || "";

      setDebug({ resolve: res1.data, oembed: o });

      setStatus("Rendering…");
      await render();
      document.getElementById("downloadBtn").disabled = false;
      setStatus("Ready.");
    }

    async function render() {
      const canvas = document.getElementById("card");
      const ctx = canvas.getContext("2d");
      const W = canvas.width, H = canvas.height;

      const showCover = document.getElementById("optCover").checked;
      const showTitle = document.getElementById("optTitle").checked;
      const showArtist = document.getElementById("optArtist").checked;
      const showYear = document.getElementById("optYear").checked;

      // Live overrides while typing
      const manualArtist = document.getElementById("artistManual").value.trim();
      const manualYear = document.getElementById("yearManual").value.trim();

      const title = state.title || "—";
      const artist = manualArtist || state.artist || "Unknown artist";
      const year = manualYear || state.year || "";

      // Plain background (match reference)
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#0b0b0d";
      ctx.fillRect(0, 0, W, H);

      // Layout tuned for 638×300 reference
      const padX = 34;
      const coverSize = 182;
      const gap = 46;

      const coverX = padX;
      const coverY = Math.round((H - coverSize) / 2);

      const textX = coverX + coverSize + gap;
      const textMaxW = W - textX - padX;

      // Cover
      if (showCover && state.coverUrl) {
        try {
          const img = await loadImage(state.coverUrl);
          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.55)";
          ctx.shadowBlur = 18;
          ctx.shadowOffsetY = 6;
          roundRectImage(ctx, img, coverX, coverY, coverSize, coverSize, 22);
          ctx.restore();
        } catch (e) {}
      }

      // Text block: center the title+artist(+year) vertically like the reference
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";

      const titleSize = 56;
      const artistSize = 22;
      const yearSize = 18;

      const titleLineH = 64;
      const artistLineH = 30;
      const yearLineH = 24;

      let blockH = 0;
      if (showTitle) blockH += titleLineH;
      if (showArtist) blockH += artistLineH;
      if (showYear && year) blockH += yearLineH;

      // subtle spacing like Spotify banner
      if (showTitle && showArtist) blockH += 12;
      if (showArtist && showYear && year) blockH += 8;

      let y = Math.round((H - blockH) / 2) + titleSize; // baseline for first line

      if (showTitle) {
        ctx.fillStyle = "rgba(255,255,255,0.94)";
        ctx.font = `800 ${titleSize}px system-ui, -apple-system, Segoe UI, Roboto, 'PingFang TC', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif`;
        y = drawWrappedText(ctx, title, textX, y, textMaxW, titleLineH, 1);
        y += 12;
      }

      if (showArtist) {
        ctx.fillStyle = "rgba(255,255,255,0.70)";
        ctx.font = `650 ${artistSize}px system-ui, -apple-system, Segoe UI, Roboto, 'PingFang TC', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif`;
        y = drawWrappedText(ctx, artist, textX, y, textMaxW, artistLineH, 1);
        y += 8;
      }

      if (showYear && year) {
        ctx.fillStyle = "rgba(255,255,255,0.46)";
        ctx.font = `600 ${yearSize}px system-ui, -apple-system, Segoe UI, Roboto, 'PingFang TC', 'Noto Sans TC', 'Microsoft JhengHei', sans-serif`;
        ctx.fillText(year, textX, y);
      }
    }

    function downloadPng() {
      const canvas = document.getElementById("card");
      const a = document.createElement("a");
      a.download = "spotify-banner-638x300.png";
      a.href = canvas.toDataURL("image/png");
      a.click();
    }

    // ---- helpers ----
    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    function roundedRectPath(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function roundRectImage(ctx, img, x, y, w, h, r) {
      ctx.save();
      roundedRectPath(ctx, x, y, w, h, r);
      ctx.clip();
      ctx.drawImage(img, x, y, w, h);
      ctx.restore();
    }

    // Returns updated y after drawing (up to maxLines)
    function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight, maxLines) {
      // For this banner POC we keep maxLines=1, but still ellipsize if too long
      const str = String(text || "");
      let out = str;
      while (ctx.measureText(out).width > maxWidth && out.length > 1) {
        out = out.slice(0, -1);
      }
      if (out !== str) out = out.slice(0, Math.max(0, out.length-1)) + "…";
      ctx.fillText(out, x, y);
      return y + lineHeight;
    }

    // Initial placeholder render
    render();
  </script>
</body>
</html>
